// ============================================================================
// mainwindow.cpp - Implementation of MpvWidget and MainWindow Classes
// ============================================================================
// This file contains all the actual code (implementation) for the classes
// declared in mainwindow.h. In C++, it's common to separate declarations
// (header files) from implementations (.cpp files) for better organization
// and faster compilation times.
// ============================================================================

// ----------------------------------------------------------------------------
// Include Statements
// ----------------------------------------------------------------------------
// #include directives copy the contents of header files into this file.
// This gives us access to class definitions and function declarations.
// ----------------------------------------------------------------------------

#include "mainwindow.h"          // Our own header - class declarations for MpvWidget
// and MainWindow

#include "ui_mainwindow.h"       // Auto-generated by Qt's UI compiler (uic) from
// mainwindow.ui. Contains the Ui::MainWindow class
// with all widgets defined in Qt Designer.

#include <QVBoxLayout>           // Vertical box layout - arranges widgets top-to-bottom.
// One of Qt's layout managers for automatic widget
// positioning and resizing.

#include <QHBoxLayout>           // Horizontal box layout - arranges widgets left-to-right.

#include <QPushButton>           // A clickable button widget.

#include <QFileInfo>             // Provides file information (name, path, size, etc.).
// We use it to extract just the filename from a full path.

#include <QApplication>          // Application-wide functionality. We use it here for
// processEvents() to flush the event queue.

#include <QDebug>                // Qt's debugging output. qDebug() is like cout but
// integrates with Qt Creator's output panel.

#include <locale.h>              // Needed for using standardized locale data

// ============================================================================
//
//                          MpvWidget IMPLEMENTATION
//
// ============================================================================
// MpvWidget wraps the MPV media player library, providing a clean C++/Qt
// interface for video playback. Each instance manages one independent player.
// ============================================================================

// ----------------------------------------------------------------------------
// Constructor: MpvWidget::MpvWidget
// ----------------------------------------------------------------------------
// Initializes a new MPV player instance and sets up the timer for UI updates.
//
// The syntax "MpvWidget(QWidget *parent) : QWidget(parent), mpv(nullptr), ..."
// is called a "member initializer list". It's the preferred way to initialize
// member variables in C++ because:
//   1. It's more efficient (initializes directly, no assignment after construction)
//   2. It's required for const members and references
//   3. It ensures proper initialization order
// ----------------------------------------------------------------------------
MpvWidget::MpvWidget(QWidget *parent) : QWidget(parent), mpv(nullptr), statusLabel(nullptr), timeLabel(nullptr), subtitleCombo(nullptr), audioCombo(nullptr) {

    // Set the widget's background color to black using CSS-like syntax.
    // Qt's stylesheets work similarly to CSS in web development.
    // This widget is actually hidden in our app, but we set it anyway.
    setStyleSheet("background-color: black;");

    // ------------------------------------------------------------------------
    // Create the MPV Player Instance
    // ------------------------------------------------------------------------
    // mpv_create() allocates and returns a new MPV player handle.
    // This handle is used for ALL subsequent MPV API calls.
    // Returns nullptr if allocation fails (rare, usually means out of memory).
    // ------------------------------------------------------------------------
    mpv = mpv_create();
    if (!mpv) {
        // qDebug() outputs to the debug console (visible in Qt Creator).
        // The "<<" operator works like cout - you can chain multiple values.
        qDebug() << "Failed to create MPV instance!";
        return;  // Early return - don't try to configure a null player
    }

    // ------------------------------------------------------------------------
    // Configure MPV Options (BEFORE initialization)
    // ------------------------------------------------------------------------
    // IMPORTANT: mpv_set_option_* functions MUST be called BEFORE mpv_initialize().
    // After initialization, you must use mpv_set_property_* instead.
    //
    // We intentionally do NOT set the "wid" (window ID) option. When wid is set,
    // MPV embeds its video output into that window. By not setting it, MPV
    // creates its own separate window for video playback. This allows users
    // to freely position and resize the video windows independently.
    // ------------------------------------------------------------------------

    // "keep-open=yes" keeps the player window open after the video ends,
    // showing the last frame. Without this, the window would close immediately.
    mpv_set_option_string(mpv, "keep-open", "yes");

    // Disable MPV's built-in keyboard shortcuts. We want our Qt UI to handle
    // all user input, not MPV's default bindings (which could conflict).
    mpv_set_option_string(mpv, "input-default-bindings", "no");

    // Disable keyboard input to the video output window specifically.
    // This prevents the video window from capturing keyboard events.
    mpv_set_option_string(mpv, "input-vo-keyboard", "no");

    // Disable terminal/console output from MPV.
    // This prevents MPV from printing status messages to stdout/stderr,
    // which could clutter logs or cause issues on some platforms.
    mpv_set_option_string(mpv, "terminal", "no");

    // CRITICAL LINUX FIX:
    // Running multiple MPV instances with hardware decoding (hwdec) enabled
    // causes crashes on Linux due to driver/context conflicts in the same process.
    // We disable it to force software decoding, which is thread-safe and stable.
    mpv_set_option_string(mpv, "hwdec", "no");

    // OPTIONAL STABILITY BOOST:
    // If 'hwdec=no' alone doesn't fix it, uncomment the line below.
    // The default "gpu" output can sometimes conflict when two windows share
    // the same application process. "x11" is a basic, safe fallback.
    mpv_set_option_string(mpv, "vo", "x11");

    // ------------------------------------------------------------------------
    // Initialize MPV
    // ------------------------------------------------------------------------
    // mpv_initialize() finalizes the player setup. After this call:
    //   - Options can no longer be set (only properties)
    //   - The player is ready to load and play files
    // Returns 0 on success, negative error code on failure.
    // ------------------------------------------------------------------------
    mpv_initialize(mpv);

    // ------------------------------------------------------------------------
    // Setup the Polling Timer
    // ------------------------------------------------------------------------
    // We use a QTimer to periodically update the time display (current position
    // and duration). This is a simple polling approach.
    //
    // Alternative: MPV supports an event-based approach using mpv_observe_property()
    // which is more efficient but more complex to implement.
    //
    // IMPORTANT: We create the timer but do NOT start it yet!
    // Starting it before a file is loaded would cause issues because we'd be
    // polling for time-pos on an empty player, which can return errors or
    // cause freezes during the sensitive initialization period.
    // ------------------------------------------------------------------------
    pollTimer = new QTimer(this);  // "this" makes MpvWidget the timer's parent.
    // Qt's parent-child system automatically
    // deletes children when parent is deleted.

    pollTimer->setInterval(500);    // Fire every 500 milliseconds (twice per second).
    // This gives smooth time updates without
    // excessive CPU usage.

    // Connect the timer's timeout signal to our onTimerTick slot.
    // This is Qt's signal-slot mechanism:
    //   - When pollTimer emits timeout(), Qt automatically calls onTimerTick()
    //   - The & syntax takes the address of the member functions
    //   - Qt handles all the plumbing automatically
    connect(pollTimer, &QTimer::timeout, this, &MpvWidget::onTimerTick);
}

// ----------------------------------------------------------------------------
// Destructor: MpvWidget::~MpvWidget
// ----------------------------------------------------------------------------
// Called when the MpvWidget is destroyed (deleted or goes out of scope).
// We delegate to shutdown() to ensure clean MPV termination.
// ----------------------------------------------------------------------------
MpvWidget::~MpvWidget() {
    shutdown();
}

// ----------------------------------------------------------------------------
// shutdown() - Clean MPV Termination
// ----------------------------------------------------------------------------
// This function safely shuts down the MPV player. It's carefully designed to
// avoid deadlocks and crashes that can occur if MPV isn't shut down properly.
//
// This was one of the trickiest parts of the application to get right!
// Different approaches were tried, and this sequence was found to work
// reliably across platforms (especially important on macOS).
// ----------------------------------------------------------------------------
void MpvWidget::shutdown() {
    // Step 1: Stop the polling timer FIRST.
    // If the timer fires while we're shutting down MPV, it would try to
    // query properties from a partially-destroyed player = crash!
    if (pollTimer) {
        pollTimer->stop();           // Stop firing events
        pollTimer->deleteLater();    // Schedule for deletion (safer than delete)
        // deleteLater() waits for the event loop
        // to be clear before actually deleting
        pollTimer = nullptr;         // Mark as gone to prevent double-delete
    }

    if (mpv) {
        // Step 2: Pause playback immediately.
        // This stops any ongoing decoding/rendering, making subsequent
        // operations safer and faster.
        int flag = 1;  // 1 = true = paused
        mpv_set_property(mpv, "pause", MPV_FORMAT_FLAG, &flag);

        // Step 3: Stop playback and unload the current file.
        // The "stop" command clears the playlist and releases resources
        // associated with the current video (decoders, video output, etc.).
        const char *stopCmd[] = {"stop", NULL};  // MPV commands are NULL-terminated
        // arrays of strings
        mpv_command(mpv, stopCmd);

        // Step 4: Send the quit command ASYNCHRONOUSLY.
        // The async version returns immediately without waiting for MPV to
        // fully shut down. This is crucial to avoid deadlocks!
        //
        // The first argument (0) is a "reply userdata" that would be included
        // in the reply event - we don't use it here.
        const char *quitCmd[] = {"quit", NULL};
        mpv_command_async(mpv, 0, quitCmd);

        // Step 5: Release our handle to MPV.
        // IMPORTANT: We use mpv_destroy(), NOT mpv_terminate_destroy()!
        //
        // mpv_terminate_destroy() waits for MPV to fully shut down, which can
        // cause deadlocks on some platforms (especially macOS) when the video
        // output is still attached to a window.
        //
        // mpv_destroy() just releases our handle immediately. MPV continues
        // cleaning up in the background on its own threads.
        mpv_destroy(mpv);
        mpv = nullptr;  // Mark as gone to prevent use-after-free bugs
    }
}

// ----------------------------------------------------------------------------
// loadVideo() - Load and Play a Video File
// ----------------------------------------------------------------------------
// Loads a video file and starts playback. This function also updates the UI
// and triggers refresh of audio/subtitle track lists.
//
// Parameter:
//   path - Full path to the video file (QString is Qt's string class)
// ----------------------------------------------------------------------------
void MpvWidget::loadVideo(QString path) {
    // Guard clause: do nothing if MPV isn't initialized
    if (!mpv) return;

    // Enforce "C" locale right here.
    // This protects us even if QProcessEvents or a Dialog reset it
    // milliseconds earlier. This is crucial for MPV parsing.
    setlocale(LC_NUMERIC, "C");

    // Step 1: STOP the polling timer during loading.
    // The load operation can take time (file probing, decoder init, etc.).
    // Polling during this sensitive period can cause hangs or incorrect data.
    pollTimer->stop();

    // Step 2: Convert QString to UTF-8 bytes for MPV's C API.
    // MPV's API uses C strings (char*), but Qt uses QString.
    // toUtf8() converts to a QByteArray containing UTF-8 encoded bytes.
    // .data() returns a pointer to the raw bytes (char*).
    QByteArray pathBytes = path.toUtf8();

    // Step 3: Execute the "loadfile" command.
    // MPV commands are arrays of C strings, terminated with NULL.
    // "loadfile" takes the path as its argument.
    const char *cmd[] = {"loadfile", pathBytes.data(), NULL};
    mpv_command(mpv, cmd);  // This blocks until the file is probed and ready
    // (or fails). For large files over network, this
    // could take a moment.

    // Step 4: Update the filename display in the UI.
    // QFileInfo extracts file information from a path.
    // fileName() returns just the filename without the directory path.
    if (statusLabel) {
        QFileInfo fileInfo(path);
        statusLabel->setText(fileInfo.fileName());
    }

    // Step 5: RESTART the polling timer now that loading is complete.
    // It's now safe to query time-pos and duration.
    pollTimer->start();

    // Step 6: Refresh the audio and subtitle track dropdowns.
    // We use QTimer::singleShot to delay this by 500ms because:
    //   - MPV needs time to fully parse the file and enumerate tracks
    //   - If we query immediately, we might get incomplete results
    //
    // singleShot() fires once after the specified delay, then stops.
    // The syntax connects directly to our member functions.
    QTimer::singleShot(500, this, &MpvWidget::refreshSubtitleTracks);
    QTimer::singleShot(500, this, &MpvWidget::refreshAudioTracks);
}

// ----------------------------------------------------------------------------
// closeVideo() - Stop Playback and Reset UI
// ----------------------------------------------------------------------------
// Unloads the current video and resets all UI elements to their default state.
// This doesn't destroy the MPV instance - it's ready to load another file.
// ----------------------------------------------------------------------------
void MpvWidget::closeVideo() {
    if (!mpv) return;

    // Stop the timer - no need to poll when nothing is playing
    pollTimer->stop();

    // Execute the "stop" command to unload the file and clear the playlist
    const char *cmd[] = {"stop", NULL};
    mpv_command(mpv, cmd);

    // Reset the filename label
    if (statusLabel) {
        statusLabel->setText("No file loaded");
    }

    // Reset the time display
    if (timeLabel) {
        timeLabel->setText("--:--:-- / --:--:--");
    }

    // Reset the subtitle dropdown to just "Off"
    if (subtitleCombo) {
        // blockSignals(true) temporarily prevents the combo box from emitting
        // signals when we modify it. Without this, our modifications would
        // trigger currentIndexChanged, which would call setSubtitleTrack(),
        // which would be wasteful and could cause issues.
        subtitleCombo->blockSignals(true);
        subtitleCombo->clear();            // Remove all items
        subtitleCombo->addItem("Off", 0);  // Add back just the "Off" option
        subtitleCombo->blockSignals(false);// Re-enable signals
    }

    // Reset the audio dropdown (empty since no file is loaded)
    if (audioCombo) {
        audioCombo->blockSignals(true);
        audioCombo->clear();
        audioCombo->blockSignals(false);
    }
}

// ----------------------------------------------------------------------------
// onTimerTick() - Timer Callback for Time Display Updates
// ----------------------------------------------------------------------------
// This slot is called every 500ms by pollTimer. It queries MPV for the
// current playback position and duration, then updates the time label.
// ----------------------------------------------------------------------------
void MpvWidget::onTimerTick() {
    if (!mpv) return;

    double timePos = 0;   // Current playback position in seconds
    double duration = 0;  // Total video duration in seconds

    // Query MPV properties using mpv_get_property().
    // Parameters:
    //   - mpv: the player handle
    //   - property name: "time-pos" or "duration"
    //   - format: MPV_FORMAT_DOUBLE for floating-point seconds
    //   - pointer to variable to receive the value
    //
    // These properties return the current playback time and total duration.
    // If no file is loaded, they return 0 or an error (which we ignore).
    mpv_get_property(mpv, "time-pos", MPV_FORMAT_DOUBLE, &timePos);
    mpv_get_property(mpv, "duration", MPV_FORMAT_DOUBLE, &duration);

    // Update the time label with formatted time strings
    if (timeLabel) {
        // QString's arg() method replaces %1, %2, etc. with the provided values.
        // It's Qt's type-safe alternative to printf-style formatting.
        QString text = QString("%1 / %2")
                           .arg(formatTime(timePos))     // Current position
                           .arg(formatTime(duration));   // Total duration
        timeLabel->setText(text);
    }
}

// ----------------------------------------------------------------------------
// formatTime() - Convert Seconds to HH:MM:SS String
// ----------------------------------------------------------------------------
// Utility function to convert a time in seconds (e.g., 3661.5) to a
// human-readable string (e.g., "01:01:01").
//
// Parameter:
//   totalSeconds - Time in seconds (can be fractional)
//
// Returns:
//   QString in "HH:mm:ss" format
// ----------------------------------------------------------------------------
QString MpvWidget::formatTime(double totalSeconds) {
    // Handle negative values (shouldn't happen, but defensive programming)
    if (totalSeconds < 0) totalSeconds = 0;

    // Start with a QTime of 00:00:00
    QTime t(0, 0, 0);

    // Add the seconds (truncated to integer).
    // static_cast<int> safely converts double to int (C++ style cast).
    t = t.addSecs(static_cast<int>(totalSeconds));

    // Format as string using Qt's date/time formatting.
    // "HH" = hours with leading zero, "mm" = minutes, "ss" = seconds
    return t.toString("HH:mm:ss");
}

// ----------------------------------------------------------------------------
// setVolume() - Set Playback Volume
// ----------------------------------------------------------------------------
// Sets the audio volume level.
//
// Parameter:
//   value - Volume level from 0 (mute) to 100 (full)
// ----------------------------------------------------------------------------
void MpvWidget::setVolume(int value) {
    if (!mpv) return;

    // MPV's volume property expects a double, so we convert.
    // Note: MPV supports values > 100 for amplification, but we limit to 0-100.
    double v = static_cast<double>(value);

    // Set the "volume" property. Unlike options, properties can be changed
    // at any time after initialization.
    mpv_set_property(mpv, "volume", MPV_FORMAT_DOUBLE, &v);
}

// ----------------------------------------------------------------------------
// togglePause() - Toggle Play/Pause State
// ----------------------------------------------------------------------------
// Toggles between playing and paused states. If playing, pauses. If paused,
// resumes playback.
// ----------------------------------------------------------------------------
void MpvWidget::togglePause() {
    if (!mpv) return;

    // The "cycle" command toggles a property between its possible values.
    // For "pause" (a boolean), it toggles between true and false.
    // This is simpler than reading the current state and setting the opposite.
    const char *cmd[] = {"cycle", "pause", NULL};
    mpv_command(mpv, cmd);
}

// ----------------------------------------------------------------------------
// seek() - Seek Forward or Backward
// ----------------------------------------------------------------------------
// Seeks the playback position by the specified number of seconds.
//
// Parameter:
//   seconds - Number of seconds to seek (positive = forward, negative = back)
// ----------------------------------------------------------------------------
void MpvWidget::seek(double seconds) {
    if (!mpv) return;

    // Use QString::number to guarantee a DOT decimal separator regardless of locale.
    // std::to_string() uses the global locale, which is risky if it ever drifts.
    std::string timeStr = QString::number(seconds, 'f', 3).toStdString();

    const char *cmd[] = {"seek", timeStr.c_str(), "relative", NULL};
    mpv_command(mpv, cmd);

    // Update the time display immediately for better UI responsiveness.
    // Without this, there would be up to a 500ms delay before the display updates.
    onTimerTick();
}

// ----------------------------------------------------------------------------
// refreshSubtitleTracks() - Populate Subtitle Track Dropdown
// ----------------------------------------------------------------------------
// Queries MPV for all available subtitle tracks and populates the subtitle
// dropdown with them. This includes embedded subtitles and any external
// subtitle files that have been loaded.
// ----------------------------------------------------------------------------
void MpvWidget::refreshSubtitleTracks() {
    if (!mpv || !subtitleCombo) return;

    // Block signals while modifying the combo box (see closeVideo for explanation)
    subtitleCombo->blockSignals(true);
    subtitleCombo->clear();

    // Add "Off" option first. The second parameter (0) is the "user data" -
    // we store the subtitle ID (sid) there. sid=0 means no subtitles.
    subtitleCombo->addItem("Off", 0);

    // ------------------------------------------------------------------------
    // Query MPV's Track List
    // ------------------------------------------------------------------------
    // "track-list" is a complex property that returns information about all
    // tracks (video, audio, subtitle) in the current file. It's returned as
    // an mpv_node, which is MPV's way of representing complex data structures
    // (similar to JSON).
    // ------------------------------------------------------------------------
    mpv_node trackList;
    if (mpv_get_property(mpv, "track-list", MPV_FORMAT_NODE, &trackList) >= 0) {
        // The track list is an array of tracks
        if (trackList.format == MPV_FORMAT_NODE_ARRAY) {
            // Iterate through each track
            for (int i = 0; i < trackList.u.list->num; i++) {
                mpv_node *track = &trackList.u.list->values[i];

                // Each track is a map (dictionary) of properties
                if (track->format != MPV_FORMAT_NODE_MAP) continue;

                // Variables to store track properties as we parse them
                QString type;          // "video", "audio", or "sub"
                int64_t id = 0;        // Track ID (used to select it)
                QString title;         // Track title (if any)
                QString lang;          // Language code (e.g., "eng", "jpn")
                bool isExternal = false; // Whether it's from an external file

                // Parse the track's properties by iterating through the map
                for (int j = 0; j < track->u.list->num; j++) {
                    const char *key = track->u.list->keys[j];
                    mpv_node *val = &track->u.list->values[j];

                    // strcmp compares C strings - returns 0 if equal
                    if (strcmp(key, "type") == 0 && val->format == MPV_FORMAT_STRING) {
                        type = QString::fromUtf8(val->u.string);
                    } else if (strcmp(key, "id") == 0 && val->format == MPV_FORMAT_INT64) {
                        id = val->u.int64;
                    } else if (strcmp(key, "title") == 0 && val->format == MPV_FORMAT_STRING) {
                        title = QString::fromUtf8(val->u.string);
                    } else if (strcmp(key, "lang") == 0 && val->format == MPV_FORMAT_STRING) {
                        lang = QString::fromUtf8(val->u.string);
                    } else if (strcmp(key, "external") == 0 && val->format == MPV_FORMAT_FLAG) {
                        isExternal = val->u.flag;
                    }
                }

                // Only process subtitle tracks (skip video and audio)
                if (type == "sub") {
                    // Build a descriptive label for the dropdown
                    QString label = QString("#%1").arg(id);
                    if (!lang.isEmpty()) label += " [" + lang + "]";
                    if (!title.isEmpty()) label += " " + title;
                    if (isExternal) label += " (external)";

                    // Add to dropdown with track ID as user data
                    subtitleCombo->addItem(label, static_cast<int>(id));
                }
            }
        }
        // IMPORTANT: Free the memory allocated by MPV for the node data
        mpv_free_node_contents(&trackList);
    }

    // Select the currently active subtitle track in the dropdown
    int64_t currentSid = 0;
    mpv_get_property(mpv, "sid", MPV_FORMAT_INT64, &currentSid);
    for (int i = 0; i < subtitleCombo->count(); i++) {
        if (subtitleCombo->itemData(i).toInt() == currentSid) {
            subtitleCombo->setCurrentIndex(i);
            break;
        }
    }

    subtitleCombo->blockSignals(false);  // Re-enable signals
}

// ----------------------------------------------------------------------------
// setSubtitleTrack() - Switch Subtitle Track
// ----------------------------------------------------------------------------
// Changes the active subtitle track based on dropdown selection.
//
// Parameter:
//   index - Index of the selected item in the subtitle dropdown
// ----------------------------------------------------------------------------
void MpvWidget::setSubtitleTrack(int index) {
    if (!mpv || !subtitleCombo) return;

    // Get the subtitle ID (sid) stored as user data for this item
    int sid = subtitleCombo->itemData(index).toInt();
    int64_t sidValue = sid;

    // Set MPV's "sid" (subtitle ID) property to switch tracks.
    // sid=0 means no subtitles (Off).
    mpv_set_property(mpv, "sid", MPV_FORMAT_INT64, &sidValue);
}

// ----------------------------------------------------------------------------
// loadExternalSubtitles() - Load Subtitle File from Disk
// ----------------------------------------------------------------------------
// Loads an external subtitle file (e.g., .srt, .ass) and adds it to the
// available subtitle tracks.
//
// Parameter:
//   path - Full path to the subtitle file
// ----------------------------------------------------------------------------
void MpvWidget::loadExternalSubtitles(QString path) {
    if (!mpv) return;

    setlocale(LC_NUMERIC, "C");

    // Convert QString to UTF-8 for MPV's C API
    QByteArray pathBytes = path.toUtf8();

    // "sub-add" command adds an external subtitle file.
    // "auto" means MPV should auto-select it if it's the first subtitle.
    const char *cmd[] = {"sub-add", pathBytes.data(), "auto", NULL};
    mpv_command(mpv, cmd);

    // Refresh the track list to show the newly added subtitle
    refreshSubtitleTracks();

    // Select the newly added track (it should be the last one in the list)
    if (subtitleCombo && subtitleCombo->count() > 0) {
        subtitleCombo->setCurrentIndex(subtitleCombo->count() - 1);
    }
}

// ----------------------------------------------------------------------------
// refreshAudioTracks() - Populate Audio Track Dropdown
// ----------------------------------------------------------------------------
// Similar to refreshSubtitleTracks(), but for audio tracks.
// Queries MPV for all available audio tracks and populates the dropdown.
// ----------------------------------------------------------------------------
void MpvWidget::refreshAudioTracks() {
    if (!mpv || !audioCombo) return;

    audioCombo->blockSignals(true);
    audioCombo->clear();

    // Query the track list (same as for subtitles)
    mpv_node trackList;
    if (mpv_get_property(mpv, "track-list", MPV_FORMAT_NODE, &trackList) >= 0) {
        if (trackList.format == MPV_FORMAT_NODE_ARRAY) {
            for (int i = 0; i < trackList.u.list->num; i++) {
                mpv_node *track = &trackList.u.list->values[i];
                if (track->format != MPV_FORMAT_NODE_MAP) continue;

                QString type;
                int64_t id = 0;
                QString title;
                QString lang;
                int64_t channels = 0;  // Number of audio channels

                // Parse track properties
                for (int j = 0; j < track->u.list->num; j++) {
                    const char *key = track->u.list->keys[j];
                    mpv_node *val = &track->u.list->values[j];

                    if (strcmp(key, "type") == 0 && val->format == MPV_FORMAT_STRING) {
                        type = QString::fromUtf8(val->u.string);
                    } else if (strcmp(key, "id") == 0 && val->format == MPV_FORMAT_INT64) {
                        id = val->u.int64;
                    } else if (strcmp(key, "title") == 0 && val->format == MPV_FORMAT_STRING) {
                        title = QString::fromUtf8(val->u.string);
                    } else if (strcmp(key, "lang") == 0 && val->format == MPV_FORMAT_STRING) {
                        lang = QString::fromUtf8(val->u.string);
                    } else if (strcmp(key, "demux-channel-count") == 0 && val->format == MPV_FORMAT_INT64) {
                        channels = val->u.int64;  // Audio channel count
                    }
                }

                // Only process audio tracks
                if (type == "audio") {
                    // Build descriptive label
                    QString label = QString("#%1").arg(id);
                    if (!lang.isEmpty()) label += " [" + lang + "]";
                    if (!title.isEmpty()) label += " " + title;

                    // Add human-readable channel configuration
                    if (channels > 0) {
                        if (channels == 1) label += " (Mono)";
                        else if (channels == 2) label += " (Stereo)";
                        else if (channels == 6) label += " (5.1)";    // 5.1 surround
                        else if (channels == 8) label += " (7.1)";    // 7.1 surround
                        else label += QString(" (%1ch)").arg(channels);
                    }

                    audioCombo->addItem(label, static_cast<int>(id));
                }
            }
        }
        mpv_free_node_contents(&trackList);
    }

    // Select current audio track
    int64_t currentAid = 0;
    mpv_get_property(mpv, "aid", MPV_FORMAT_INT64, &currentAid);
    for (int i = 0; i < audioCombo->count(); i++) {
        if (audioCombo->itemData(i).toInt() == currentAid) {
            audioCombo->setCurrentIndex(i);
            break;
        }
    }

    audioCombo->blockSignals(false);
}

// ----------------------------------------------------------------------------
// setAudioTrack() - Switch Audio Track
// ----------------------------------------------------------------------------
// Changes the active audio track based on dropdown selection.
//
// Parameter:
//   index - Index of the selected item in the audio dropdown
// ----------------------------------------------------------------------------
void MpvWidget::setAudioTrack(int index) {
    if (!mpv || !audioCombo) return;

    int aid = audioCombo->itemData(index).toInt();
    int64_t aidValue = aid;

    // Set MPV's "aid" (audio ID) property to switch tracks
    mpv_set_property(mpv, "aid", MPV_FORMAT_INT64, &aidValue);
}

// ============================================================================
//
//                         MainWindow IMPLEMENTATION
//
// ============================================================================
// MainWindow is the main application window. It creates and arranges all the
// UI elements (buttons, sliders, labels) and connects them to the two
// MpvWidget instances that control the video players.
// ============================================================================

// ----------------------------------------------------------------------------
// Constructor: MainWindow::MainWindow
// ----------------------------------------------------------------------------
// Creates the entire user interface programmatically (without Qt Designer).
// This is a large function because it sets up all widgets and connections.
// ----------------------------------------------------------------------------
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)                    // Call parent constructor
    , ui(new Ui::MainWindow)                 // Create the UI object
{
    // Setup the UI from the .ui file (required even if we override everything)
    ui->setupUi(this);

    // Set the window's default size (width x height in pixels)
    // The user can still resize the window, but it starts at this size.
    resize(900, 450);

    // ------------------------------------------------------------------------
    // Create the Main Layout Structure
    // ------------------------------------------------------------------------
    // Qt uses layout managers to automatically arrange widgets. When the
    // window resizes, layouts automatically adjust widget positions and sizes.
    //
    // We use a QVBoxLayout as the main container, with nested layouts inside.
    // ------------------------------------------------------------------------

    // Create a central widget to hold everything.
    // QMainWindow requires a central widget - it can't have layouts directly.
    QWidget *centralContainer = new QWidget(this);
    setCentralWidget(centralContainer);

    // Main vertical layout - arranges children from top to bottom
    QVBoxLayout *mainLayout = new QVBoxLayout(centralContainer);
    mainLayout->setSpacing(4);  // 4 pixels between items (compact layout)

    // Horizontal layout for the two player columns (side by side)
    QHBoxLayout *videoArea = new QHBoxLayout();
    videoArea->setSpacing(0);  // No spacing - we'll add a visual divider instead

    // ------------------------------------------------------------------------
    // Lambda Function to Create Player UI
    // ------------------------------------------------------------------------
    // This is a C++ lambda (anonymous function) that creates the UI for one
    // player. We use a lambda to avoid duplicating code for player 1 and 2.
    //
    // Lambda syntax: [capture](parameters) -> return_type { body }
    // [this] captures "this" pointer so we can access MainWindow members.
    // The (MpvWidget*& playerRef, QString title) are parameters.
    // -> QVBoxLayout* specifies the return type.
    // ------------------------------------------------------------------------
    auto createPlayerColumn = [this](MpvWidget*& playerRef, QString title) -> QVBoxLayout* {
        // Create a vertical layout for this player's controls
        QVBoxLayout *col = new QVBoxLayout();
        col->setSpacing(4);  // Compact spacing

        // --------------------------------------------------------------------
        // Header Label (e.g., "Player 1 (Left)")
        // --------------------------------------------------------------------
        QLabel *header = new QLabel(title);
        header->setStyleSheet("font-weight: bold; font-size: 14px;");
        col->addWidget(header);

        // --------------------------------------------------------------------
        // Create the MpvWidget (hidden - video plays in separate window)
        // --------------------------------------------------------------------
        // The MpvWidget manages the MPV instance but doesn't display video.
        // We hide it since video playback happens in MPV's own window.
        playerRef = new MpvWidget();
        playerRef->setVisible(false);

        // --------------------------------------------------------------------
        // Info Row: Filename and Time Display
        // --------------------------------------------------------------------
        QHBoxLayout *infoRow = new QHBoxLayout();

        // Filename label
        QLabel *fileLabel = new QLabel("No file loaded");
        fileLabel->setStyleSheet("color: #333; font-weight: bold;");
        fileLabel->setWordWrap(true);  // Allow text to wrap if too long

        // QSizePolicy controls how widgets behave when space is limited.
        // "Ignored" horizontal policy means the label won't force the window wider
        // when a long filename is displayed - it will wrap instead.
        fileLabel->setSizePolicy(QSizePolicy::Ignored, QSizePolicy::Preferred);

        // Time display label
        QLabel *timeLabel = new QLabel("--:--:-- / --:--:--");
        timeLabel->setStyleSheet("color: #0055aa; font-family: monospace;");
        timeLabel->setAlignment(Qt::AlignRight | Qt::AlignVCenter);

        // Fixed width prevents layout jumping when time changes (e.g., 9:59 -> 10:00)
        timeLabel->setFixedWidth(130);

        // Add to layout. The "1" gives fileLabel a stretch factor, making it
        // take up all available space while timeLabel stays fixed-width.
        infoRow->addWidget(fileLabel, 1);
        infoRow->addWidget(timeLabel);
        col->addLayout(infoRow);

        // Store label pointers in MpvWidget so it can update them
        playerRef->statusLabel = fileLabel;
        playerRef->timeLabel = timeLabel;

        // --------------------------------------------------------------------
        // Seek Controls Row: << 1m, < 10s, 10s >, 1m >>
        // --------------------------------------------------------------------
        QHBoxLayout *seekRow = new QHBoxLayout();
        QPushButton *btnBack1m  = new QPushButton("<< 1m");   // Back 1 minute
        QPushButton *btnBack10s = new QPushButton("< 10s");   // Back 10 seconds
        QPushButton *btnFwd10s  = new QPushButton("10s >");   // Forward 10 seconds
        QPushButton *btnFwd1m   = new QPushButton("1m >>");   // Forward 1 minute
        seekRow->addWidget(btnBack1m);
        seekRow->addWidget(btnBack10s);
        seekRow->addWidget(btnFwd10s);
        seekRow->addWidget(btnFwd1m);
        col->addLayout(seekRow);

        // --------------------------------------------------------------------
        // Main Controls Row: Load, Close, Play/Pause, Volume
        // --------------------------------------------------------------------
        QHBoxLayout *controls = new QHBoxLayout();

        QPushButton *btnLoad = new QPushButton("Load");    // Open file dialog
        QPushButton *btnClose = new QPushButton("Close");  // Unload video
        QPushButton *btnPlay = new QPushButton("Play/Pause");

        // Volume slider: horizontal orientation, range 0-100, default 50%
        QSlider *volSlider = new QSlider(Qt::Horizontal);
        volSlider->setRange(0, 100);
        volSlider->setValue(50);

        // Red text for Close button to indicate it's a "destructive" action
        btnClose->setStyleSheet("color: #aa0000;");

        controls->addWidget(btnLoad);
        controls->addWidget(btnClose);
        controls->addWidget(btnPlay);
        controls->addWidget(new QLabel("Vol:"));  // Label created inline
        controls->addWidget(volSlider);
        col->addLayout(controls);

        // --------------------------------------------------------------------
        // Subtitle Controls Row: Dropdown + Load External Subtitle Button
        // --------------------------------------------------------------------
        QHBoxLayout *subRow = new QHBoxLayout();
        QLabel *subLabel = new QLabel("Subs:");

        // Combo box (dropdown) for subtitle selection
        QComboBox *subCombo = new QComboBox();
        subCombo->addItem("Off", 0);       // Default: no subtitles
        subCombo->setMinimumWidth(120);    // Ensure dropdown is readable

        QPushButton *btnLoadSub = new QPushButton("Load Sub...");

        subRow->addWidget(subLabel);
        subRow->addWidget(subCombo, 1);    // Stretch factor 1 = expand to fill
        subRow->addWidget(btnLoadSub);
        col->addLayout(subRow);

        // Store combo pointer in MpvWidget
        playerRef->subtitleCombo = subCombo;

        // --------------------------------------------------------------------
        // Audio Controls Row: Just a Dropdown (no external audio loading)
        // --------------------------------------------------------------------
        QHBoxLayout *audioRow = new QHBoxLayout();
        QLabel *audioLabel = new QLabel("Audio:");

        QComboBox *audioCombo = new QComboBox();
        audioCombo->setMinimumWidth(120);

        audioRow->addWidget(audioLabel);
        audioRow->addWidget(audioCombo, 1);
        col->addLayout(audioRow);

        playerRef->audioCombo = audioCombo;

        // --------------------------------------------------------------------
        // Connect Signals to Slots (Wire Up the UI)
        // --------------------------------------------------------------------
        // Qt's signal-slot mechanism connects UI events to handler functions.
        // The connect() function links a signal (e.g., button click) to a
        // slot (handler function).
        //
        // We use lambdas (inline functions) for simple handlers. The [=]
        // captures all local variables by value, letting us use playerRef
        // inside the lambda.
        // --------------------------------------------------------------------

        // Seek button connections
        connect(btnBack1m,  &QPushButton::clicked, [=]() { playerRef->seek(-60.0); });
        connect(btnBack10s, &QPushButton::clicked, [=]() { playerRef->seek(-10.0); });
        connect(btnFwd10s,  &QPushButton::clicked, [=]() { playerRef->seek(10.0); });
        connect(btnFwd1m,   &QPushButton::clicked, [=]() { playerRef->seek(60.0); });

        // Load button - opens a file dialog
        connect(btnLoad, &QPushButton::clicked, this, [=]() {
            // QFileDialog::getOpenFileName shows a native file picker.
            // Parameters: parent, title, starting directory, file filter
            QString fileName = QFileDialog::getOpenFileName(this, "Select Video", "", "Videos (*.mp4 *.mkv *.avi *.mov *webm)");

            // CRITICAL: QFileDialog on Linux often resets LC_NUMERIC to the system default
            // (e.g., using commas for decimals). We MUST reset it to "C" immediately,
            // or MPV will crash when it tries to process numbers in background threads.
            setlocale(LC_NUMERIC, "C");

            if (!fileName.isEmpty()) {
                // Process any pending events. This helps on macOS where file
                // permission dialogs can interfere with subsequent operations.
                QApplication::processEvents();

                // Use a short delay before loading. This gives macOS time to
                // finalize any permission grants from the file dialog.
                // On other platforms, this tiny delay is imperceptible.
                QTimer::singleShot(100, [=]() {
                    playerRef->loadVideo(fileName);
                });
            }
        });

        // Close button
        connect(btnClose, &QPushButton::clicked, [=]() { playerRef->closeVideo(); });

        // Play/Pause button
        connect(btnPlay, &QPushButton::clicked, [=]() { playerRef->togglePause(); });

        // Volume slider - valueChanged fires whenever the slider moves
        connect(volSlider, &QSlider::valueChanged, [=](int value) { playerRef->setVolume(value); });

        // Subtitle dropdown - currentIndexChanged fires when selection changes.
        // QOverload<int>::of() is needed because QComboBox has overloaded signals.
        connect(subCombo, QOverload<int>::of(&QComboBox::currentIndexChanged),
                [=](int index) { playerRef->setSubtitleTrack(index); });

        // Load external subtitle button
        connect(btnLoadSub, &QPushButton::clicked, this, [=]() {
            QString subFile = QFileDialog::getOpenFileName(this, "Select Subtitle File", "",
                                                           "Subtitles (*.srt *.ass *.ssa *.sub *.vtt);;All Files (*)");
            setlocale(LC_NUMERIC, "C"); // Set locale to expected time.
            if (!subFile.isEmpty()) {
                QApplication::processEvents();  // Same macOS workaround as above
                QTimer::singleShot(100, [=]() {
                    playerRef->loadExternalSubtitles(subFile);
                });
            }
        });

        // Audio dropdown
        connect(audioCombo, QOverload<int>::of(&QComboBox::currentIndexChanged),
                [=](int index) { playerRef->setAudioTrack(index); });

        return col;  // Return the completed layout
    };

    // ------------------------------------------------------------------------
    // Build the Two Player Columns
    // ------------------------------------------------------------------------

    // Create Player 1's UI column
    QVBoxLayout *leftCol = createPlayerColumn(player1, "Player 1 (Left)");
    videoArea->addLayout(leftCol);

    // Add a vertical dividing line between the two players.
    // QFrame can draw lines using its frameShape property.
    QFrame *vLine = new QFrame();
    vLine->setFrameShape(QFrame::VLine);    // Vertical line
    vLine->setFrameShadow(QFrame::Sunken);  // 3D sunken effect
    videoArea->addWidget(vLine);

    // Create Player 2's UI column
    QVBoxLayout *rightCol = createPlayerColumn(player2, "Player 2 (Right)");
    videoArea->addLayout(rightCol);

    // Add the video area (both players) to the main layout
    mainLayout->addLayout(videoArea);

    // ------------------------------------------------------------------------
    // Global Controls Section (affects both players simultaneously)
    // ------------------------------------------------------------------------

    // Horizontal dividing line separating player controls from global controls
    QFrame *line = new QFrame();
    line->setFrameShape(QFrame::HLine);     // Horizontal line
    line->setFrameShadow(QFrame::Sunken);
    mainLayout->addWidget(line);

    // Global seek buttons
    QHBoxLayout *globalSeek = new QHBoxLayout();
    QPushButton *gBack1m  = new QPushButton("Global << 1m");
    QPushButton *gBack10s = new QPushButton("Global < 10s");
    QPushButton *gFwd10s  = new QPushButton("Global 10s >");
    QPushButton *gFwd1m   = new QPushButton("Global 1m >>");

    globalSeek->addWidget(gBack1m);
    globalSeek->addWidget(gBack10s);
    globalSeek->addWidget(gFwd10s);
    globalSeek->addWidget(gFwd1m);
    mainLayout->addLayout(globalSeek);

    // Global play/pause buttons
    QHBoxLayout *globalControls = new QHBoxLayout();
    QPushButton *btnGlobalPause = new QPushButton("Global Pause");
    QPushButton *btnGlobalPlay  = new QPushButton("Global Play");

    // Make these buttons taller for emphasis (they're important!)
    btnGlobalPause->setMinimumHeight(40);
    btnGlobalPlay->setMinimumHeight(40);

    globalControls->addWidget(btnGlobalPause);
    globalControls->addWidget(btnGlobalPlay);
    mainLayout->addLayout(globalControls);

    // ------------------------------------------------------------------------
    // Connect Global Controls
    // ------------------------------------------------------------------------
    // Global buttons affect BOTH players simultaneously.
    // ------------------------------------------------------------------------

    // Global seek - applies seek to both players
    connect(gBack1m,  &QPushButton::clicked, [=]() { player1->seek(-60); player2->seek(-60); });
    connect(gBack10s, &QPushButton::clicked, [=]() { player1->seek(-10); player2->seek(-10); });
    connect(gFwd10s,  &QPushButton::clicked, [=]() { player1->seek(10);  player2->seek(10); });
    connect(gFwd1m,   &QPushButton::clicked, [=]() { player1->seek(60);  player2->seek(60); });

    // Global Pause - sets pause=true on both players
    connect(btnGlobalPause, &QPushButton::clicked, this, [=]() {
        int flag = 1;  // 1 = paused
        // Check that MPV is valid before accessing it
        if (player1->mpv) mpv_set_property(player1->mpv, "pause", MPV_FORMAT_FLAG, &flag);
        if (player2->mpv) mpv_set_property(player2->mpv, "pause", MPV_FORMAT_FLAG, &flag);
    });

    // Global Play - sets pause=false on both players
    connect(btnGlobalPlay, &QPushButton::clicked, this, [=]() {
        int flag = 0;  // 0 = not paused = playing
        if (player1->mpv) mpv_set_property(player1->mpv, "pause", MPV_FORMAT_FLAG, &flag);
        if (player2->mpv) mpv_set_property(player2->mpv, "pause", MPV_FORMAT_FLAG, &flag);
    });
}

// ----------------------------------------------------------------------------
// Destructor: MainWindow::~MainWindow
// ----------------------------------------------------------------------------
// Cleans up resources when the window is destroyed.
// ----------------------------------------------------------------------------
MainWindow::~MainWindow()
{
    // Shut down both players (safe to call even if already shut down)
    if (player1) player1->shutdown();
    if (player2) player2->shutdown();

    // Delete the UI object created in the constructor
    delete ui;
}

// ----------------------------------------------------------------------------
// closeEvent() - Handle Window Close
// ----------------------------------------------------------------------------
// This virtual function is called when the user tries to close the window
// (clicking X, pressing Alt+F4, etc.). We override it to ensure clean
// shutdown of MPV before the window is destroyed.
//
// Without this, the application could hang or crash because:
//   1. Qt would destroy the window widgets
//   2. MPV might still be rendering to those destroyed widgets
//   3. Deadlock or crash!
//
// Parameter:
//   event - Contains information about the close event. We can accept() it
//           to allow the close, or ignore() it to prevent closing.
// ----------------------------------------------------------------------------
void MainWindow::closeEvent(QCloseEvent *event) {
    // Step 1: Close any loaded videos (stop playback, release resources)
    if (player1) player1->closeVideo();
    if (player2) player2->closeVideo();

    // Step 2: Process pending events so MPV can handle the stop commands
    // before we destroy the players.
    QApplication::processEvents();

    // Step 3: Fully shut down the MPV instances
    if (player1) player1->shutdown();
    if (player2) player2->shutdown();

    // Step 4: Accept the close event (allow the window to close)
    event->accept();
}
